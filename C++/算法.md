## 一，双指针法

**通过两个指针在一个for循环下完成两个for循环的工作。**

### 例题1：移除数组元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**思路**：

定义快慢指针

- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

当快指针指向的不是需要移除的元素，就将快指针的值赋给慢指针，否则快指针跳过该值。最后（0，slowindex）的数组就是整理后的数组

```cpp
// 时间复杂度：O(n)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```



### 例题2：环形链表

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

**说明**：不允许修改给定的链表。

**思路**：

- **使用快慢指针判断是否有环**

  分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。

- **找到环入口**

  假设从链表头到环的起点的距离为 `a`，环的起点到两指针相遇点的距离为 `b`，相遇点回到环的起点的距离为 `c`。当慢指针进入环时，快指针已经在环内。	为了让它们相遇，假设慢指针走了 `b` 的距离，快指针就走了 `b+c` 的距离，因为它的速度是慢指针的两倍。所以我们有：	

```java
2(a+b) = a+b+c+b
a+b = c+b
a = c
```

​		这意味着从链表头到环的起点的距离等于从相遇点到环的起点的距离。

​		因此，当我们发现慢指针和快指针相遇时，我们可以将一个新的指针（比如 `ptr`）设置在链表的头部，并使其与慢指针以相同的速度移动。当这个新指针和		慢指针相遇时，它们会在环的起点相遇

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
            // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇
            if (slow == fast) {
                ListNode* index1 = fast;
                ListNode* index2 = head;
                while (index1 != index2) {
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index2; // 返回环的入口
            }
        }
        return NULL;
    }
};
```



### 例题3：三数之和（N数之和）

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

**注意：** 答案中不可以包含重复的三元组。

**思路**：

先将数组升序，定义两个指针分别指向数组最左端（min）和最右端（max），遍历两指针间的元素，当发现三者之和过大（右指针左移），过小（左指针右移）直到左右指针相遇（注意去重与剪枝的方式）

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        // 找出a + b + c = 0
        // a = nums[i], b = nums[left], c = nums[right]
        for (int i = 0; i < nums.size(); i++) {
            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) {
                return result;
            }
           
            // 正确去重a方法
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                if (nums[i] + nums[left] + nums[right] > 0) right--;
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
                else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }

        }
        return result;
    }
};
```

三数之和的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到`nums[i] + nums[left] + nums[right] == 0`。

四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出`nums[k] + nums[i] + nums[left] + nums[right] == target`的情况，三数之和的时间复杂度是O(n^2^)，四数之和的时间复杂度是O(n^3^) 。

那么N数之和也都是这种方法。

**三数之和的双指针法就是将原本暴力O(n^3^)的解法，降为O(n^2^)的解法，四数之和的双指针解法就是将原本暴力O(n^4^)的解法，降为O(n^3^)的解法。**

------



## 二，KMP算法

KMP算法是一种用于在一个文本串S内查找一个模式串P的高效字符串匹配算法。

通过利用部分匹配表，KMP算法能够避免不必要的回溯，实现高效的字符串匹配。

**KMP算法的核心思想是利用已经部分匹配的信息来避免重复的比较，从而提高匹配的效率**

### 1.前缀表

这个表用来存储模式串P中每个位置的最长公共前后缀的长度，**它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**

因为前缀表记录的是最长公共前后缀，当模式串与文本串匹配失败的时候（失败位置之前的匹配都是成功的），此时==失败位置的前缀与模式串前面某元素的前缀相同==，因此可以移动指针到模式串的该元素，使其达到前缀部分与文本串相同的时候，重新匹配。

### 2.next数组实现前缀表

next数组可以就是前缀表，也可以是前缀表减一后的结果（本文默认该种实现方式）

**构造next数组其实就是计算模式串s，前缀表的过程。** 主要有如下三步：

1. 初始化
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况

```cpp
void getNext(int* next, const string& s){
    int j = -1;//前缀表统一减一，此时j+1才是当前位置
    next[0] = j;
    for(int i = 1; i < s.size(); i++) { // 注意i从1开始
        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
            j++;
        }
        next[i] = j; // 将j（前缀的长度）赋给next[i]
    }
}
```

**流程动画如下**（借用代码随想录）

![](E:\桌面\MyNoteBook\C++\KMP.gif)

### 3.使用next数组作匹配

**思路**

定义两个下标，j 指向模式串起始位置，i指向文本串起始位置。

 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。

如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。

如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串

```cpp
int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);// 获取前缀表
        int j = -1; // 因为next数组里记录的起始位置为-1
        for (int i = 0; i < haystack.size(); i++) { // 注意i就从0开始
            while(j >= 0 && haystack[i] != needle[j + 1]) { // 不匹配
                j = next[j]; // j 寻找之前匹配的位置
            }
            if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动
                j++; // i的增加在for循环里
            }
            if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t
                return (i - needle.size() + 1);// 返回在文本串中出现的第一个位置
            }
        }
        return -1;
    }
```

- 时间复杂度: O(n + m)
- 空间复杂度: O(m), 只需要保存字符串needle的前缀表

------

## 三，排序算法

排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。

| 名称     | 平均时间复杂度 | 最好情况     | 最坏情况     | 空间复杂度 | 排序方式  | 稳定性 |
| -------- | -------------- | ------------ | ------------ | ---------- | --------- | ------ |
| 冒泡排序 | O(n^2^)        | O(n)         | O(n^2^)      | O(1)       | In-place  | 稳定   |
| 选择排序 | O(n^2^)        | O(n^2^)      | O(n^2^)      | O(1)       | In-place  | 不稳定 |
| 插入排序 | O(n^2^)        | O(n)         | O(n^2^)      | O(1)       | In-place  | 稳定   |
| 希尔排序 | O(n logn)      | O(n log^2^n) | O(n log^2^n) | O(1)       | In-place  | 不稳定 |
| 归并排序 | O(n logn)      | O(n logn)    | O(n logn)    | O(n)       | Out-place | 稳定   |
| 快速排序 | O(n logn)      | O(n logn)    | O(n^2^)      | O(logn)    | In-place  | 不稳定 |
| 堆排序   | O(n logn)      | O(n logn)    | O(n logn)    | O(1)       | In-place  | 不稳定 |
| 计数排序 | O(n+k)         | O(n+k)       | O(n+k)       | O(k)       | Out-place | 稳定   |
| 桶排序   | O(n+k)         | O(n+k)       | O(n^2^)      | O(n+k)     | Out-place | 稳定   |
| 基数排序 | O(n x k)       | O(n x k)     | O(n x k)     | O(n+k)     | Out-place | 稳定   |

### 1.冒泡排序

**算法步骤**

比较相邻的元素。如果第一个比第二个大，就交换他们两个；

对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；

针对所有的元素重复以上的步骤，除了最后一个；

持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较；

![](E:\桌面\MyNoteBook\C++\bubbleSort.gif)

**代码实现**

```cpp
void bubble_sort(int arr[], int len)
{
    for (int i = 0; i < len - 1; i++)
    {
        for (int j = 0; j < len - 1 - i; j++)
        {
            if (arr[j] > arr[j + 1])
                swap(arr[j], arr[j + 1]);
        }
    }
}
```

**个人理解**

每次拿出待排序元素的第一个，依次与后面的元素比较，将大的元素往后冒，因而数组最末尾是已经排好序的元素，冒泡的第二层循环不与这些已经排好序的元素比较，因此条件为`j<len-1-i`。

### 2.选择排序

**算法步骤**

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；

再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；

重复第二步，直到所有元素均排序完毕；

![](E:\桌面\MyNoteBook\C++\selectionSort.gif)

**代码实现**

```cpp
void selection_sort(int arr[], int len)
{
    int minIndex = 0;
    for (int i = 0; i < len; i++)
    {
        for (int j = i + 1; j < len; j++)
            if (arr[j] < arr[minIndex])
                minIndex = j;
        if (arr[i] > arr[minIndex])
            swap(arr[i], arr[minIndex]);
    }
}
```

**个人理解**

每次先选取未排序元素的第一个（i+1），然后依次遍历后面元素，找到最小值，与选取的未排序元素互换位置（能实现将依次找到的最小值按序排放在数组前端）

### 3.插入排序

**算法步骤**

将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列；

从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面）；

![](E:\桌面\MyNoteBook\C++\insertionSort.gif)

**代码实现**

```cpp
void insertion_sort(int arr[], int len)
{
    for (int i = 1; i < len; i++)
    {
        for (int j = i ; j >= 1 && arr[j]<arr[j-1]; j--)
        {
          std::swap(arr[j],arr[j-1]);
        }
    }
}
```

**个人理解**

选取元素A与前面已经排序好的元素依次比较，如果比A大则将这些已排好序的元素后移（与选取的元素交换位置），比A小则停止循环，恰好让A落在已排序元素的最末端

### 4.希尔排序

**算法步骤**

选择一个步长h，依次构成子序列，进行插入排序；

然后外层循环使得`h--`，缩短步长，再次按子序列插入排序；

直到`h=1`，退化为插入排序；

![](E:\桌面\MyNoteBook\C++\Sorting_shellsort_anim.gif)

**代码实现**

```cpp
void shell_sort(int arr[], int len)
{
    int h = 1;
    while (h < len / 3)
    {
        h = 3 * h + 1;// 选择合适的步长
    }
    while (h >= 1)
    {
        for (int i = h; i < len; i++)// i从h开始，对应每个子序列的第二个元素，依次往后
        {
            for (int j = i; j >= h && arr[j] < arr[j - h]; j -= h)
            {
                std::swap(arr[j], arr[j - h]);
            }
        }
        h = h / 3;
    }
}
```

**个人理解**

相当于进行了多次的按照步长的子序列插入排序，第一层for循环针对每一个分好的子序列，第二个for循环针对每个子序列内部进行插入排序，最外层while循环控制步长的缩小

### 5.归并排序

**算法步骤**

递归的划分子数组，再依次往上合并；

合并过程：申请空间，该空间用来存放合并后的序列；设定两个指针，最初位置分别为两个已经排序序列的起始位置；比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；重复直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾；

最后将临时空间存放的数组元素(已经排序完成)，放回到原数组；

![](E:\桌面\MyNoteBook\C++\mergeSort.gif)

**代码实现**

```cpp
void merge(int arr[], int temparr[], int left, int mid, int right)
{
    // 进行合并 重排序
    // 使用双指针排序
    int l_pos = left;
    int r_pos = mid + 1;
    int pos = left; // 指向用于存放排序后的数组

    while (l_pos <= mid && r_pos <= right)
    {
        if (arr[l_pos] < arr[r_pos])
        {
            temparr[pos++] = arr[l_pos++];
        }
        else
        {
            temparr[pos++] = arr[r_pos++];
        }
    }

    // 左半区有剩余元素 直接移到最后面
    while (l_pos <= mid)
    {
        temparr[pos++] = arr[l_pos++];
    }

    // 右半区有剩余元素 直接移到最后面
    while (r_pos <= right)
    {
        temparr[pos++] = arr[r_pos++];
    }
    // 将排序后的数组再复制回原数组
    while (left <= right)
    {
        arr[left] = temparr[left];
        left++;
    }
}
void msort(int arr[], int temparr[], int left, int right)
{
    if (left < right)
    { // 递归二分子数组
        int mid = (left + right) / 2;
        msort(arr, temparr, left, mid);
        msort(arr, temparr, mid + 1, right);
        merge(arr, temparr, left, mid, right);//合并
    }
}
void merge_sort(int arr[], int len)
{
    int *temparr = new int[len];
    msort(arr, temparr, 0, len - 1); // 归并排序人口
    delete temparr;
}
```



**个人理解**

分治法实现的一种排序方式，以空间换时间

### 6.快速排序

**算法步骤**

选定基准并保存到变量，定义左右指针，从右指针往左找第一个比基准小的，覆盖基准的原始位置，接着右指针不动，移动左指针，找第一个比基准大的，并覆盖之前右指针指向的位置（如今看作空位）；

接着再移动右指针，重复上面步骤，直到左右指针相遇，相遇点即为基准的最后位置；

最后以基准为中心，左右递归的实现上述过程；

![](E:\桌面\MyNoteBook\C++\quickSort.gif)

**代码实现**

```cpp
int Paritition(int arr[],int low,int high){
    int pivot=arr[low];
    while(low<high){
        while(low<high&&arr[high]>=pivot) high--;
        arr[low]=arr[high];
        while(low<high&&arr[low]<=pivot) low++;
        arr[high]=arr[low];
    }
    arr[low]=pivot;
    return low;
}
void quick_sort(int arr[],int low,int high){
    if(low<high){
        int p=Paritition(arr,low,high);
        quick_sort(arr,low,p-1);
        quick_sort(arr,p+1,high);
    }
}
```



**个人理解**

同样是分治法的体现，快速排序通常比其他同样时间复杂度的其他排序算法更快。算法核心就是找中位数，再以中位数左右递归，完成排序

### 7.堆排序

**算法步骤**

创建一个堆 H[0……n-1]并维护为大顶堆；

把堆首（最大值）和堆尾互换；

把堆的尺寸缩小 1，并维护大顶堆，目的是把新的数组顶端数据调整到相应位置；

同时将堆顶放至待排序数组的末尾；

重复步骤 ，直到堆的尺寸为 1；

![](E:\桌面\MyNoteBook\C++\heapSort.gif)

**代码实现**

```cpp
void max_haepify(int arr[],int start,int end){// 维护大顶堆，保证最大端为最大值
    // 建立父节点和子节点指针
    int dad=start;// 堆顶
    int son=dad*2+1;// 左子节点
    while(son<=end){
        if(son+1<=end&&arr[son]<arr[son+1])// 比较左右子节点 取大值
            son++;
        if(arr[dad]>arr[son]) return;// 已经是大顶堆
        else{
            swap(arr[dad],arr[son]);
            dad=son;
            son=dad*2+1;
        }
    }
}
void heap_sort(int arr[],int len){
    //建堆
    for(int i=len/2-1;i>=0;i--) max_haepify(arr,i,len-1);// 从下往上建堆
    for(int i=len-1;i>0;i--){
        swap(arr[0],arr[i]);// 将堆顶（最大值）依次从数组末尾往前放（升序）
        max_haepify(arr,0,i-1);// 重新维护移除了堆顶后的大顶堆
    }
}
```



**个人理解**

每次都维护好大顶堆，然后将堆顶依次从后往前放至数组，完成排序

其中`len/2-1`是最末尾的子节点对应的父节点，从此开始向上建堆

### 8.计数排序

**算法步骤**

找出待排序的数组中最大元素（用于开辟临时数组C）；

统计数组中每个值为i的元素出现的次数，存入数组C的第i项；

对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；

反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1；

![](E:\桌面\MyNoteBook\C++\countingSort.gif)

**代码实现**

```cpp
void counting_sort(int arr[],int len){
    int maxVal=arr[0];
    for(int i=0;i<len;i++) maxVal=max(maxVal,arr[i]);
    //计数
    int *count=new int[maxVal+1]{0};
    for(int i=0;i<len;i++) count[arr[i]]++;
    for(int i=1;i<maxVal+1;i++) count[i]+=count[i-1];
    int *output=new int[len]{0};
    for(int i=0;i<len;i++){//count[i]表示包括i在内共有几个数，因此count[i]-1表示在本元素前有几个数，是排序后的正确位置
        output[count[arr[i]]-1]=arr[i];
        count[arr[i]]--;
    }
    for(int i=0;i<len;i++){//复制到原数组
        arr[i]=output[i];
    }
    delete[] count;
    delete[] output;
}
```

**个人理解**

计算每个元素出现的个数（哈希表），然后求个数的前缀和，此时count[i]表示包括i在内共有几个数，以此确定对应元素的正确位置，填充到输出数组中，便完成排序（只适用于纯数字排序）

### 9.基数排序

**算法步骤**

先求出数组元素的最大位数，并开辟10个桶用于存放位数上0-9的元素；

初始化桶，依次按照从低到高的位数，循环的将元素放入桶中；

再将桶中的元素依次放回原数组，完成一次排序；

重复上述步骤，直到循环到最高位时，再放回原数组即完成排序；

![](E:\桌面\MyNoteBook\C++\radixSort.gif)

**代码实现**

```cpp
int digit(int n){
    int k=0;
    while(n!=0){
        n/=10;
        k++;
    }
    return k;
}
void radix_sort(int arr[], int len){
    int maxN=arr[0];
    for(int i=0;i<len;i++) maxN=max(arr[i],maxN);
    int k=digit(maxN);// 计算最大值位数
    int num,Y=1;
    vector<vector<int>> count(10, vector<int>(len));
    for(int i=1;i<=k;i++){// i表示位数
        // 将桶每个元素置为0
        for (int j = 0; j < count.size(); j++)
        {
            count[j].assign(len,0);
        }
        // 循环拿出每一个数
        for(int j=0;j<len;j++){
            num=arr[j]/Y%10;
            count[num][++count[num][0]]=arr[j];// 0下标存储该数字桶的元素个数
        }

        int a_len=0;
        for(int n=0;n<=9;n++){
            for(int m=1;m<=count[n][0];m++){
                arr[a_len++]=count[n][m];// 把每个数字桶中的元素逐个放回数组，完成一次排序
            }
        }
       Y*=10; // 下一个位数
    }
}
```



**个人理解**

原理是**将整数按位数切割成不同的数字，然后按每个位数分别比较**。

### 10.桶排序

**算法步骤**

确定桶的个数，遍历数组，确定每个元素在哪个桶中；

将元素有序插入桶中（链表实现）；

遍历每个桶，依次合并桶；

将最终得到的大桶（链表）元素依次放回数组；

![](E:\桌面\MyNoteBook\C++\Bucket_sort_1.svg_.png)

![](E:\桌面\MyNoteBook\C++\Bucket_sort_2.svg_.png)

**代码实现**

```cpp
const int BUCKET_NUM = 10;
struct ListNode
{
    // 构造函数，参数i默认为0
    explicit ListNode(int i = 0) : mData(i), mNext(NULL) {} // explicit关键字表示该构造函数是显式的,不能隐式转换
    // 指向下一个节点的指针
    ListNode *mNext;
    // 节点数据
    int mData;
};

ListNode *insert(ListNode *head, int val) // 插入一个新节点并返回插入后的头结点
{
    // 创建一个虚拟节点
    ListNode dummyNode;
    // 创建一个新节点
    ListNode *newNode = new ListNode(val);
    // 定义两个指针
    ListNode *pre, *curr;
    // 虚拟节点的下一个节点指向头节点
    dummyNode.mNext = head;
    // 定义前一个指针指向虚拟节点
    pre = &dummyNode;
    // 定义当前指针指向头节点
    curr = head;
    // 当前指针不为空，且当前指针指向的节点的数据小于等于val
    while (NULL != curr && curr->mData <= val)
    {
        // 将当前指针指向的前一个指针指向当前指针指向的节点
        pre = curr;
        // 将当前指针指向下一个节点
        curr = curr->mNext;
    }
    // 将新节点指向当前指针指向的节点
    newNode->mNext = curr;
    // 将前一个指针指向新节点
    pre->mNext = newNode;
    // 返回虚拟节点的下一个节点
    return dummyNode.mNext;
}

ListNode *Merge(ListNode *head1, ListNode *head2) // 合并两链表并返回新链表的头结点
{
    // 创建一个虚拟节点
    ListNode dummyNode;
    ListNode *dummy = &dummyNode;
    // 当两个链表都不为空时，比较节点数据，将较小的节点接到虚拟节点后面
    while (NULL != head1 && NULL != head2)
    {
        if (head1->mData <= head2->mData)
        {
            dummy->mNext = head1;
            head1 = head1->mNext;
        }
        else
        {
            dummy->mNext = head2;
            head2 = head2->mNext;
        }
        dummy = dummy->mNext;
    }
    // 将两个链表剩余的节点接到虚拟节点后面
    if (NULL != head1)
        dummy->mNext = head1;
    if (NULL != head2)
        dummy->mNext = head2;

    // 返回虚拟节点的下一个节点，即合并后的新链表
    return dummyNode.mNext;
}

void bucket_sort(int arr[],int n)
{
    // 初始化桶
    vector<ListNode *> buckets(BUCKET_NUM, (ListNode *)(0));
    for (int i = 0; i < n; ++i)
    {
        // 计算每个元素在桶中的位置，哪个桶
        int index = arr[i] / BUCKET_NUM;
        // 获取桶头节点
        ListNode *head = buckets.at(index);
        // 将元素插入桶中（有序）
        buckets.at(index) = insert(head, arr[i]);
    }
    // 合并桶
    //在本排序算法中，可以不合并桶，因为前一个桶中所有元素必然比后面的桶小，因此可以逐个遍历所有桶，并将元素依次放入数组即是有序
    ListNode *head = buckets.at(0);
    for (int i = 1; i < BUCKET_NUM; ++i)
    {
        head = Merge(head, buckets.at(i));
    }
    // 将桶中的元素重新赋值给数组
    for (int i = 0; i < n; ++i)
    {
        arr[i] = head->mData;
        head = head->mNext;
    }
}
```



**个人理解**

按一定的数目划分数组元素，在这些划分（桶）中各自进行排序，最后再依次遍历每个桶（各个桶在划分时便以及排好序），放入数组

------

## 四，Morris遍历二叉树

Morris遍历是一种不使用栈的方法来实现二叉树的遍历，它能够以O(1)的空间复杂度和O(n)的时间复杂度完成遍历。

### 前序遍历

```apl
step1：判断当前结点的左孩子是否为空，若是则输出当前结点，并更新当前结点为当前结点的右孩子；否则进入第二步。
step2：在当前结点的左子树中寻找左子树中最右结点作为前驱结点；
a.若前驱结点的右孩子为空，则将前驱结点的右孩子指向当前结点，输出当前结点，当前结点更新为当前结点的左孩子，进入第三步；
b.若前驱结点的右孩子为当前结点（不为空），将前驱结点的右孩子置为NULL，当前结点更新为当前结点的右孩子，进入第三步；
step3：若当前结点不为空，进入第一步，否则程序结束；
```

```c++
void morrisPreorderTraversal(TreeNode* root) {
    TreeNode* current = root;
    while (current != nullptr) {
        if (current->left == nullptr) {
            std::cout << current->val << " ";
            current = current->right;
        } else {
            TreeNode* predecessor = current->left;
            while (predecessor->right != nullptr && predecessor->right != current) {
                predecessor = predecessor->right;
            }
            if (predecessor->right == nullptr) {
                std::cout << current->val << " ";
                predecessor->right = current;
                current = current->left;
            } else {
                predecessor->right = nullptr;
                current = current->right;
            }
        }
    }
}
```

### 中序遍历

```apl
step1：判断当前结点的左孩子是否为空，若是则输出当前结点，并更新当前结点为当前结点的右孩子；否则进入第二步。
step2：在当前结点的左子树中寻找左子树中最右结点作为前驱结点；
a.若前驱结点的右孩子为空，则将前驱结点的右孩子指向当前结点，当前结点更新为当前结点的左孩子，进入第三步；
b.若前驱结点的右孩子为当前结点（不为空），将前驱结点的右孩子置为NULL，输出当前结点，当前结点更新为当前结点的右孩子，进入第三步；
step3：若当前结点不为空，进入第一步，否则程序结束；
```

```c++
void morrisInorderTraversal(TreeNode* root) {
    TreeNode* current = root;
    while (current != nullptr) {
        if (current->left == nullptr) {
            std::cout << current->val << " ";
            current = current->right;
        } else {
            TreeNode* predecessor = current->left;
            while (predecessor->right != nullptr && predecessor->right != current) {
                predecessor = predecessor->right;
            }
            if (predecessor->right == nullptr) {
                predecessor->right = current;
                current = current->left;
            } else {
                predecessor->right = nullptr;
                std::cout << current->val << " ";
                current = current->right;
            }
        }
    }
}
```

### 后序遍历

```apl
新建一个Dummy结点，该结点的左孩子指向树根root，将Dummy作为当前结点；
step1：判断当前结点的左孩子是否为空，若是则更新当前结点为当前结点的右孩子；否则进入第二步；
step2：在当前结点的左子树中寻找左子树中最右结点作为前驱结点；
a.若前驱结点的右孩子为空，则将前驱结点的右孩子指向当前结点，当前结点更新为当前结点的左孩子，进入第三步；
b.若前驱结点的右孩子为当前结点（不为空），反转当前结点左孩子到前驱结点之间的路径，输出该路径所有结点；再反转恢复原状。将前驱结点的右孩子置为NULL，当前结点更新为当前结点的右孩子，进入第三步；
step3：若当前结点不为空，进入第一步，否则程序结束；
```

```c++
void reverseNodes(TreeNode* from, TreeNode* to) {
    if (from == to) {
        return;
    }
    TreeNode* x = from;
    TreeNode* y = from->right;
    TreeNode* z;
    while (true) {
        z = y->right;
        y->right = x;
        x = y;
        y = z;
        if (x == to) {
            break;
        }
    }
}

void reverseOutput(TreeNode* from, TreeNode* to, std::vector<int>& result) {
    reverseNodes(from, to);
    TreeNode* p = to;
    while (true) {
        result.push_back(p->val);
        if (p == from) {
            break;
        }
        p = p->right;
    }
    reverseNodes(to, from);
}

void morrisPostorderTraversal(TreeNode* root) {
    TreeNode dummy(0);
    dummy.left = root;
    TreeNode* current = &dummy;
    while (current != nullptr) {
        if (current->left == nullptr) {
            current = current->right;
        } else {
            TreeNode* predecessor = current->left;
            while (predecessor->right != nullptr && predecessor->right != current) {
                predecessor = predecessor->right;
            }
            if (predecessor->right == nullptr) {
                predecessor->right = current;
                current = current->left;
            } else {
                reverseOutput(current->left, predecessor, result);
                predecessor->right = nullptr;
                current = current->right;
            }
        }
    }
}
```

------

## 五，回溯算法

### 简介

回溯算法是一种通过不断尝试可能的解决方案来解决问题的算法。它通常用于解决组合优化、排列、游戏和谜题等问题。回溯算法的核心思想是在搜索过程中不断尝试各种可能的选择，当发现当前选择无法达到目标时，就回溯到上一步，尝试其他选择，直到找到解决方案或者确定无解。

回溯算法通常通过递归来实现。在每一步，算法会尝试所有可能的选择，然后递归地处理每个选择的结果。如果某个选择导致了无法继续前进，算法就会回溯到上一步，尝试其他选择。

### 算法步骤

**回溯算法通常包括以下几个步骤：**

1. 确定问题的解空间：即确定问题的解是什么，以及如何表示这些解。
2. 确定约束条件：即确定问题的限制条件，哪些选择是合法的，哪些是不合法的。
3. 递归地搜索解空间：通过递归地尝试各种可能的选择，不断深入解空间，直到找到解或者确定无解。
4. 回溯：当发现当前选择无法达到目标时，回溯到上一步，尝试其他选择。

**回溯算法的代码模板：**

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

### 例题

**1.组合总和Ⅱ**

```apl
给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次 。
注意：解集不能包含重复的组合。 
```

```ASN.1
- 通过使用used数组，标记每个使用过的元素（同树枝上）
- 如果candidates[i] == candidates[i - 1] 并且 used[i - 1] == false，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]。
```

![](E:\桌面\MyNoteBook\C++\组合总和Ⅱ.png)

```c++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 要对同一树层使用过的元素进行跳过
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            used[i] = true;
            backtracking(candidates, target, sum, i + 1, used); // 这里是i+1，每个数字在每个组合中只能使用一次
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false);
        path.clear();
        result.clear();
        // 首先把给candidates排序，让其相同的元素都挨在一起。
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, used);
        return result;
    }
};
```

**2.N皇后**

```apl
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
```

```
- 按行判定棋子位置是否合法并放入，往下递归
- 递归至叶子结点即为一种可能情况，接着回溯，在for循环中按列遍历每一种情况
- 棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度
```

```c++
class Solution {
public:
    vector<vector<string>> res;
    bool isOK(int row,int col,vector<string>& path,int n){
        for(int i=0;i<row;i++){
            if(path[i][col]=='Q') return false;
        }
        for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--){
            if(path[i][j]=='Q') return false;
        }
        for(int i=row-1,j=col+1;i>=0&&j<n;i--,j++){
            if(path[i][j]=='Q') return false;
        }
        return true;
    }
    void dfs(vector<string>& path,int n,int row){// 按行递归，依次填充棋盘
        if(row==n){
            res.push_back(path);
            return;
        }
        for(int i=0;i<n;i++){
            if(isOK(row,i,path,n)){
                path[row][i]='Q';
                dfs(path,n,row+1);
                path[row][i]='.';
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<string> path(n,string(n,'.'));
        dfs(path,n,0);
        return res;
    }
};
```

**3.单词拆分**

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

```
普通回溯深搜会导致超时问题，因此引入记忆化函数，避免重复计算

使用memory数组保存每次计算的以startIndex起始的计算结果，如果memory[startIndex]里已经被赋值了，直接用memory[startIndex]的结果。

```

```c++
class Solution {
private:
    bool backtracking (const string& s,
            const unordered_set<string>& wordSet,
            vector<bool>& memory,
            int startIndex) {
        if (startIndex >= s.size()) {
            return true;
        }
        // 如果memory[startIndex]不是初始值了，直接使用memory[startIndex]的结果
        if (!memory[startIndex]) return memory[startIndex];
        for (int i = startIndex; i < s.size(); i++) {
            string word = s.substr(startIndex, i - startIndex + 1);// 依次移动i，直到（startIndex，i）之间形成的单词可以在字典里找到（剪枝）
            if (wordSet.find(word) != wordSet.end() && backtracking(s, wordSet, memory, i + 1)) {// 以i+1为新的startindex进行深搜
                return true;
            }
        }
        memory[startIndex] = false; // 记录以startIndex开始的子串是不可以被拆分的
        return false;
    }
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> memory(s.size(), 1); // 1 表示初始化状态 都可拆分
        return backtracking(s, wordSet, memory, 0);
    }
};
```



------

## 六,Hierholzer算法求欧拉路径

Hierholzer算法是一种高效的求解欧拉路径和欧拉回路的算法。它通过遍历图中的边，保证每条边都被经过一次，从而得到欧拉路径或欧拉回路。

### 算法步骤

Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：

1. 从起点出发，进行深度优先搜索。

2. 每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。

3. 如果没有可移动的路径，则将所在节点加入到栈中，并返回。

### 相关定义

- 通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路；
- 通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路；
- 具有欧拉回路的无向图称为欧拉图；
- 具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。

### 题目描述

给定一个 *n* 个点 *m* 条边的图，要求从指定的顶点出发，经过所有的边恰好一次（可以理解为给定起点的「一笔画」问题），使得路径的字典序最小。

因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。

如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：

```apl
1.对于无向图 G，G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。
2.对于无向图 G，G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 0 个或 2 个奇度顶点。
3.对于有向图 G，G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。
4.对于有向图 G，G 是半欧拉图当且仅当
- 如果将 G 中的所有有向边退化为无向边时，那么 G 的所有顶点属于同一个强连通分量；
- 最多只有一个顶点的出度与入度差为 1；
- 最多只有一个顶点的入度与出度差为 1；
- 所有其他顶点的入度和出度相同。
```

例题：

```
给你一份航线列表 tickets，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

- 例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。

假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。
```

```c++
class Solution {
public:
    unordered_map<string, priority_queue<string, vector<string>, std::greater<string>>> vec;
    // 为了能够快速找到当前节点所连的节点中字典序最小的那一个，使用优先队列存储当前节点所连到的点
    vector<string> stk;

    void dfs(const string& curr) {
        while (vec.count(curr) && vec[curr].size() > 0) {// 遍历当前结点所有的边，
            string tmp = vec[curr].top();
            vec[curr].pop();
            dfs(move(tmp));// 深搜
        }
        stk.emplace_back(curr);// 递归返回时逆序推入结果集
    }

    vector<string> findItinerary(vector<vector<string>>& tickets) {
        for (auto& it : tickets) {
            vec[it[0]].emplace(it[1]);
        }
        dfs("JFK");

        reverse(stk.begin(), stk.end());
        return stk;
    }
};

```

> 因为贪心的往字典序小的节点深搜，我们可能先走入「死胡同」，从而导致无法遍历到其他还未访问的边。于是我们希望能够遍历完当前节点所连接的其他节点后再进入「死胡同」。

注意到只有那个入度与出度差为 1 的节点会导致死胡同。而该节点**必然是最后一个遍历到的节点**。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。

对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。

这样就能保证我们可以「一笔画」地走完所有边，最终的栈中逆序地保存了「一笔画」的结果。我们只要将栈中的内容反转，即可得到答案。

------

## 七，贪心算法

### 简介

贪心算法通过每一步选择当前最优解，从而希望最终得到全局最优解。

贪心算法的基本思想是通过局部最优选择来达到全局最优。在每一步的选择中，贪心算法会根据问题的特性和约束条件，选择当前看起来最优的解决方案，而不考虑整体的问题。贪心算法没有回溯的过程，它一旦做出选择，就不会再进行修改。

### 算法步骤

1. 确定问题的解空间，并定义目标函数。
2. 根据约束条件和目标函数，选择一个局部最优解。
3. 判断选择的局部最优解是否满足问题的解空间和约束条件，如果满足，则继续选择下一个局部最优解，直到达到全局最优解或无法选择更多解。
4. 对于满足条件的局部最优解，将其合并到问题的解集中，更新问题的解空间和约束条件。
5. 重复步骤2到步骤4，直到达到全局最优解。

尽管贪心算法通常能够以较高的效率得到近似解，但并不是所有的问题都适合使用贪心算法。贪心算法的局限性在于，它只考虑当前的最优解，而没有考虑整体的问题。因此，在使用贪心算法时，需要保证问题的特性和约束条件满足贪心选择的原则。

### 例题

**1.买卖股票的最佳时机 II**

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

**贪心算法**

```
- 可以将最终的总利润分解为每天可以获得的利润（当天减前一天）
- 将所有正利润累加

我们只需要关注最终利润，不需要记录区间
那么只收集正利润就是贪心所贪的地方
局部最优：收集每天的正利润，全局最优：求得最大利润
```

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i = 1; i < prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
```

**动态规划**

```
- dp[i][0]表示第i天未持有股票的最大利润
- dp[i][1]表示第i天持有股票的最大利润
- 递推公式：
dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);
dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);
```

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int dp[prices.size()][2];
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        for(int i=1;i<prices.size();i++){
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }
        return max(dp[prices.size()-1][0],dp[prices.size()-1][1]);
    }
};
```

**2.根据身高重建队列**

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

```
对于存在两个维度的问题，要先确定一个维度，再根据第二个维度解决问题
先按照身高确定遍历的顺序，再根据k依次插入队列的适当位置，即可完成排序

按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。

所以在按照身高从大到小排序后：
局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性
全局最优：最后都做完插入操作，整个队列满足题目队列属性
```

```c++
class Solution {
public:
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort (people.begin(), people.end(), cmp);
        vector<vector<int>> que;
        for (int i = 0; i < people.size(); i++) {
            int position = people[i][1];
            que.insert(que.begin() + position, people[i]);
        }
        return que;
    }
};
```

> vector底层在插入时会自动扩容（重新申请内存，全量拷贝），使用链表来完成元素的插入会很好的优化时间复杂度

**3.单调递增的数字**

给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

（当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。）

```
我们可以从高到低按位构造这个小于等于 n 的最大单调递增的数字。假设不考虑 n 的限制，那么对于一个长度为 k 的数字，最大单调递增的数字一定是每一位都为 9 的数字。

记 strN[i]表示数字 n 从高到低的第 i 位的数字（i 从 0 开始）。

如果整个数字 n 本身已经是按位单调递增的，那么最大的数字即为 n。

从后往前找，只要不递增，则将前一位数减1，并且标记该点，直到遍历到某点前面全部递增，则只需将该点往后的所有数重新赋值为‘9’，即是最大的递增数
```

```c++
class Solution {
public:
    int monotoneIncreasingDigits(int N) {
        string strNum = to_string(N);
        // flag用来标记赋值9从哪里开始
        // 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行
        int flag = strNum.size();
        for (int i = strNum.size() - 1; i > 0; i--) {
            if (strNum[i - 1] > strNum[i] ) {
                flag = i;
                strNum[i - 1]--;
            }
        }
        for (int i = flag; i < strNum.size(); i++) {
            strNum[i] = '9';
        }
        return stoi(strNum);
    }
};
```

------

## 八，动态规划

### 简介

动态规划是一种解决复杂问题的算法设计技术，通常用于优化问题的求解。它基于将问题分解为子问题，并通过解决这些子问题来构建问题的解。动态规划通常用于解决最优化问题，其中需要找到满足特定约束条件下的最佳解决方案。

动态规划的基本思想是将原问题拆分成更小的子问题，然后解决这些子问题，最后将它们的解组合起来以得到原问题的解。通常，动态规划问题具有最优子结构性质，即问题的最优解可以通过其子问题的最优解来构造。

#### **1.背包问题**

##### **01背包**

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

1. 二维dp数组

```
dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。

有两个方向推出来dp[i][j]，
1.不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)
2.放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值

所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

用两层循环遍历背包和物品，先遍历背包还是物品都不影响最终的结果，因为状态转移方程来源于上一个物品的状态，即使同一物品在不同容量下被考虑多次，每次都会根据当前容量的情况进行判断，以确保得到最优解。
```

```c++
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagweight = 4;

    // 二维数组
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

        }
    }

    cout << dp[weight.size() - 1][bagweight] << endl;
}
```

2. 一维dp数组（滚动数组）

```
在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

一维dp数组的递推公式
dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。
dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）

此时dp[j]有两个选择
一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i；
一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，

所以递归公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。
倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次

因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。
倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。
```

```c++
void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}
```

**不同题目的递推公式**

1.求解背包能存放的最大价值数目（仅放一次）：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

2.求解装满背包有几种方法（组合问题）：dp[j] += dp[j - nums[i]]；

**求装满背包有几种方案的遍历顺序**

1.如果求组合数就是外层for循环遍历物品，内层for遍历背包。

2.如果求排列数就是外层for遍历背包，内层for循环遍历物品。

------

##### **完全背包**

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。而完全背包的物品是可以添加多次的，所以要从小到大去遍历

从小到大遍历，因为递推公式的前一个状态可能已经放入该物品，而此时容量变大，仍然可能放入该物品，所以可以无限次放入，而反之则是01背包的情况（仅限一次）

```c++
void test_CompletePack() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = weight[i]; j <= bagWeight; j++) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}
```

------

##### **多重背包**

有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

多重背包和01背包是非常像的

每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。

因此只要将物品数量展开，再化为01背包解决问题即可

```c++
void test_CompletePack(){
    vector<int> dp(bagWeight + 1, 0);

    for(int i = 0; i < n; i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            // 以上为01背包，然后加一个遍历个数
            for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) { // 遍历个数
                dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]);
            }
        }
    }

    cout << dp[bagWeight] << endl;
}
```

#### **2.偷钱问题**

#### **3.股票买卖问题**

#### **4.子序列问题**

##### **操作序列**

给定串/数组`S`与`T`,判断`T`是否是`S`的子序列 / `S`与`T`的最长公共子序列 / 在`S`的子序列中`T`出现的个数等问题

定义时，`dp[i][j]为下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t的一系列子问题`

------

- 1.判断`T`是否是`S`的子序列：即删除S的元素使得S=T是否成立

DP定义：`dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。`

状态转移方程：

```c++
if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
else dp[i][j] = dp[i-1][j];
```

解决：最长相同子序列长度=T的长度，则T为S子序列

------

- 2.计算在 s 的子序列中 t 出现的个数：即删除S的元素使得S=T有几种可能情况

DP定义：`dp[i][j] 表示以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。`

状态转移方程：

```c++
if (s[i - 1] == t[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
    //考虑情况问题，加法公式进行情况相加，此时有两种情况：
    1.当前字符匹配成功，可能情况与前一个状态一致
    2.选择跳过当前字符，去检查S前面字符，可能也可以匹配
} 
else {
    dp[i][j] = dp[i - 1][j];// 不相等则直接检查S前面字符，因为t视为模式串，则j不变
}
```

解决：得到的`dp[s.size()][t.size()]`即为所求的t出现的个数

------

- 3.给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最少步数，每步可以删除任意一个字符串中的一个字符：即可以删除两个字符串的元素使得两串相等

DP定义：`以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。`

状态转移方程：

```c++
if (word1[i - 1] == word2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1];// 相等则不用删除
} 
else {
    // 要么删除word1的元素，比较word1前面的元素，要么删除word2的元素，比较word2前面的元素，要么两个都删除
    dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});// 求最小操作步数，取min
}
```

解决：得到的`dp[word1.size()][word2.size()]`即为所求的最小操作步数

------

- 4.给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 ：即使用增删改，操作两个单词使其相等

DP定义：`dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。`

状态转移方程：

```c++
if (word1[i - 1] == word2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1];// 相等不用操作
}
else {
    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
}
    /*
    操作一：word1增加一个元素，使其word1[i - 1]与word2[j - 1]相同，那么就是以下标i-2为结尾的word1 与 i-1为结尾的word2的最近编辑距离 加上一个增加元素的操作。即 dp[i][j] = dp[i - 1][j] + 1;
    操作二：word2添加一个元素，使其word1[i - 1]与word2[j - 1]相同，那么就是以下标i-1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 加上一个增加元素的操作。即 dp[i][j] = dp[i][j - 1] + 1;
    （删除元素就相当于在另一个串上增加元素 故不计）
    操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增加元素，那么以下标i-2为结尾的word1 与 j-2为结尾的word2的最近编辑距离 加上一个替换元素的操作。
    */
```

解决：得到的`dp[word1.size()][word2.size()]`即为所求的最小操作步数

------

##### **选择序列**

在给定的数组中选择一组数（构成序列），满足一定条件：单调递增/最大和 等

- 1.最长上升子序列

```c++
for (int i = 1; i < nums.size(); i++) {
    for (int j = 0; j < i; j++) {
        if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);//往前遍历比nums[i]小的，依次在其状态上递推
    }
    if (dp[i] > result) result = dp[i]; // 取长的子序列
}
```

- 2.最长连续递增子序列

```c++
for (int i = 1; i < nums.size(); i++) {
    if (nums[i] > nums[i - 1]) { // 连续记录，初始化dp[i]=1
        dp[i] = dp[i - 1] + 1;
    }
}
```

- 3.最大子序和

```c++
for (int i = 1; i < nums.size(); i++) {
     dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移公式
        if (dp[i] > result) result = dp[i]; // result 保存dp[i]的最大值 result初始化为nums[0]
}
```



### 算法步骤

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

### 例题

**1.整数拆分**

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

```
确定dp数组（dp table）以及下标的含义
dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。

确定递推公式
其实可以从1遍历j，然后有两种渠道得到dp[i].
一个是j * (i - j) 直接相乘。
一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。

j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。递推公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));

也可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。
```

```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j <= i / 2; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```

**2.目标和**

给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

```
可以将数组分为两个部分：add（加法）和neg（减法），其中add-neg=target且sum=add+target，所以消去add。
neg=(sum-target)/2;

问题转化为在nums数组中挑选能组成neg（背包容量）的数字有多少种可能

对于这种挑选物品（只用一次），填充背包的，使用01背包的解法
但与常规01背包求解背包中能放置的最大物品价值不同
该题要求物品价值等于容量的可能性，因此状态转移方程有一定的改变：dp[j] += dp[j - nums[i]];（适用于求组合的题目）

从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0。

当然本题也可以使用回溯深搜每种情况，在此不展开赘述
```

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(S) > sum) return 0; // 此时没有方案
        if ((S + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (S + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {// 如果先遍历背包，则会变成计算排列数问题
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
};
```

**3.单词拆分**

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

```
单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。

拆分时可以重复使用字典中的单词，说明就是一个完全背包

dp[i] = true 表示长为i的字符串都是由字典中的单词组成

如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）。

所以递推公式是 if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。
```

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {   // 遍历背包
            for (int j = 0; j < i; j++) {       // 遍历物品
                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)
                if (wordSet.find(word) != wordSet.end() && dp[j]) {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
```

**4.打家劫舍Ⅲ**

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

```
树形dp

使用二维dp数组或者两个数组维护每个结点偷与不偷的状态

因为需要叶子结点的返回值作处理，因此使用后序遍历（左右中）
```

```c++
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
    // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 偷cur，那么就不能偷左右节点。
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
};
```

**5.最长递增子序列**

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

```
dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度

在遍历到i时，第二层循环往前找比nums[i]小的元素，dp[i]在此元素基础上转移，并依次找最大值

状态转移方程：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);

最后跳出循环，将最大值记录
```

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        vector<int> dp(nums.size(), 1);
        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
            }
            if (dp[i] > result) result = dp[i]; // 取长的子序列
        }
        return result;
    }
};
```

**6.不同的子序列**

给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数，结果需要对 10^9^ + 7 取模。

```
dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。

当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。
一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1][j-1]。
一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。
例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。
当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。
所以当s[i - 1] 与 t[j - 1]相等时，dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];

当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1][j]

dp[i][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。
那么dp[i][0]一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。
```

```c++
class Solution {
public:
    int numDistinct(string s, string t) {
        vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1));//uint64_t是一种无符号整数数据类型，用于表示64位的无符号整数
        for (int i = 0; i < s.size(); i++) dp[i][0] = 1;
        for (int j = 1; j < t.size(); j++) dp[0][j] = 0;
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];// 由s的当前字符与t匹配，或者选择跳过它，去检查S前面剩余字符
                } else {
                    dp[i][j] = dp[i - 1][j];//因为t是待匹配模式串，因此j不需要减一
                }
            }
        }
        return dp[s.size()][t.size()];
    }
};
```

